---
title: "Getting Started with NextJS"
date: "2022-10-16"
image: getting-started-nextjs.png
excerpt: NextJS is a the React framework for production - it makes building fullstack React apps and sites a breeze and ships with built-in SSRdawdadadawdawdawdwadawdawddwdawdawdawdawdawdawdawdawdawdawdawddawdawdawd.
isFeatured: true
slug: http
---












# CDN

距离是硬伤，



DH算法

生成一个共享的密钥，后期的交流就通过这个密钥加密





# HTTP/1.1  ,2 , 3 的区别





1.1 ：同时也是互联网第一这真正意义的HTTP标准版本 核心是 1次一份，发送一个HTTP请求，需要等到HTTP响应，才能发送下一个HTTP请求，对于HTTP协议来说，我们打开网页，需要进行TCP三次握手，建立TCP连接，才正式请求，服务器会先发送HTML文件给我们，其他的文件不会发给我们，浏览器在收到HTML文件后，根据HTML里面的内容，再向服务器依次请求CSS，js等文件，整个过程都是浏览器在帮我们完成，所以用户的直接感受是只有一次请求，如果在请求队伍里，有一个文件没有收到，后面的文件也没法接收了，这就会造成 HTTP 对头阻塞了，











为了减少请求，也有其他办法，比如把JS和CSS合并，或者把CSS和JS整合到HTMl里，但是后面HTTPS对于1.1就更难，因为原本通信前就要进行TCP三次握手，HTTPS里的 TLS1.2又要进行握手，握手后才可以进行加密通信，虽然TLS1.3减少了来回次数，但对于1.1也是杯水车薪，越多的来回就是越多的未知。







# http2

特点：多路复用，主要就是为了解决http1.1队头阻塞的问题，http2并不是单个文件就这样直接响应过去，请求和响应报文都被划分为各个不同的帧，这个帧可以分为首部帧和数据帧，就是把原本http报文的首部和实体给拆分为两部分，所以原本的http报文就不再是原来的报文了，有点像数据链路层里的帧，最重要的是这里有个 "流标识符"，有了这个，使得帧不用按照顺序抵达对方那里，因为就算你没有按照顺序，最终有这个流标识符就可以按照顺序进行组合，而且帧类型里还可以设置优先级，这样来标注流的权重，但其实并没有完美解决队头阻塞





服务器推送；





于是就有了http3

# http3

核心：整合

http3把TCP和TLS1.3 的握手过程整合在一起了，

![image-20230320152844291](C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230320152844291.png)

直接减少了来回带来的开销，如果是恢复会话，还可以不用握手，实现 0-RTT

但问题是TCP和TLS是两个协议，不好合并，所以只能选择传输层的UDP协议，并且在基于UDP协议上新增一个协议，QUIC

![image-20230320153036195](C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230320153036195.png)



quic整合了 TPC 和 TLS ，使得HTTP3默认就是要使用加密传输的，quic是为了能够广泛部署才只能用UDP，但QUIC必须要解决TCP队头阻塞的问题，从应用层过来的数据会被封装成QUIC帧，和HTTP2的帧很像，也是加了流标识符，和HTTP2不同的是，http3的应用层上并没有所谓的帧的概念，把数据帧移到了QUIC里，相当于在传输层就有了，从源头解决队头阻塞的问题，实现多路复用，QUIC帧再次封装成QUCI数据包，上面会加上一些信息，最重要的就是加了 Connection ID 连接ID，

![image-20230320153614988](C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230320153614988.png)

如果网络发生改变，如果WIFI变成流量，虽然IP地址发生改变，但是因为客户端和服务端都协商好了连接ID，因此可以用连接ID来识别为同一个连接，避免再次握手，这也是QUIC其中一个速度快的原因，QUIC数据包也会把QUIC里面的帧加密，也就是在TLS握手后，QUIC帧的内容被加密了，接着QUIC数据包会被UDP封装为数据段，UDP就会加上端口号，当我们选择HTTP3通信时，QUIC就会像TCP那样开启连接，QUIC数据包就是在这链接通道里面收发









# 握手



传输层：实现端到端的连接

套接字 socket ： IP地址+端口号



![image-20230317201816338](C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230317201816338.png)



怎么样的握手才能判断出哪些请求或者哪些响应需要丢弃

TCP报文有以下标识,设置1就是开启，设置0就是关闭

SYN（Synchronization, 同步）

ACK（Acknowledgment 确认）

FIN（Finish 结束）



三次握手

客户端发送TCP报文的时候，会把该标识开启，SYN表示(Synchronization)，即同步的意思，表示客户端想和服务端进行数据的同步，同步之后，客户端和服务端就可以互相发送消息

但是仅仅发送SYN是不够的，还有一个重要的字段 Sequence 序号，应用程序可能可能连续发送多个序号给服务器，这样服务器起码就有依据可以判断哪些是累赘信息，而且这个 Sequence 序号是随机生成的，作为初始值进行后续的判断的依据，这样就保证了通道的唯一性

如果没有初始序号，客户端一下子发送两条数据，就可能会造成分歧

服务器接收到SYN后，就需要做出响应，服务器就会在TCP报文中把 SYN 和 ACK 开启，合起来就是 确认同步 的意思，同时服务器也生成自己的序号，但是不够，还需要加上 确认号，我们就使用 对方的 seq+1， 这样客户端收到号码后 -1 就知道是不是自己发送的TCP报文了，最后客户端还需要确认，不然服务器就不知道自己发送出去的 确认同步 是否被接收，所以还需要发送一次 TCP 报文来使连接正式建立，这时，客户端就会把 ACK 开启，这里的序号就用对方的 序号+1 

但是如果每次发过来的 SYN ，服务器都要记住这个序号，并且新生成自己需要记住的需要，那么服务器就需要挂起非常多的资源，如果有攻击者不断发送 SYN 又不进行下一步，就会导致服务器崩溃，就是典型的 DDos 攻击（Syn flood Syn洪流），因此服务器就直接不保存自己的序号，而是根据服务器的IP地址和端口号等私有信息进行算法的运算得到序号

![image-20230317204544736](C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230317204544736.png)

建立起连接之后，就可以进行书记交流了，内容交流完毕，就可能发起关闭连接的请求，即四次挥手，客户端和服务端都能主动发起关闭请求

四次挥手

假设客户端主动发起关闭要求，，客户端就会在报文中开启 FIN 和 ACK 两个控制位，即确认结束会话，在发送HTTP请求和响应的时候，序号和确认号被不断递增，这里就不使用固定数字来表示序号和确认号

服务端就发送一个 ACK 来进行确认，自己的序号用对方的确认号，自己的确认号用对方的序号+1，虽然发送了，但此时客户端并未正式关闭通道，因为服务端可能还有需要发送的数据，

直到服务端发送完数据之后，再发送一个 FIN+ACK ，来表示最后的确认，序号和确认号不需要改变（因为没有一来一回），最后客户端得到最终的结束确认以后会发送 ACK 来进行确认，自己的序号用对方的确认号，自己的确认号用对方的序号+1

![image-20230320174604336](C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230320174604336.png)

# http



每条请求报文只能写一个URL，即以此只能写一个资源路径，造成一次只能获取一个文件，对于服务器来说可以对请求进行逐个处理，每处理完一个就关闭连接，这样可以节省资源，称为 非持久连接， 

但是一次一个请求很难满足需要，而且每次都要进行一次 TCP 连接，因此在 HTTP/1.1 中，默认为持久连接，服务端返回消息，客户端可以继续发起下一个请求，如果没有要发送的了，客户端最后发送 Connection:close 首部给服务器

但是持久连接也不表示一直保持连接，是有一定时间限制的，因为如果每台主机访问同一服务器，服务器需要把他们的信息全部记录下来，这样服务器会崩溃，所以服务器不会把每个状态都记录下来，这就是 HTTP 的无状态

但是目前很多功能都是有用户登录功能，如果是无状态的，用户登陆了一次，第二次访问又需要输入信息登录，所以为了保持这种状态，有了 Cookie 这种技术，在首部字段加上 cookie， 这样就能够实现保持登录状态了



http 协议规定缓存是如何工作，如何储存和各种类型等等



代理服务器：在客户端和源服务器之间的服务器，代理服务器备份源服务器的资源作为缓存，这样客户端有需要的时候就可以之间从中间的代理服务器中索取

缓存基本原理

请求资源首先看自己有没有缓存，如果没有，就问服务器索要，如果有，就要检查缓存是否过期，如果缓存没有过期，就可以直接使用，如果过期了，就和服务器进行验证，如果服务器告知没有过期，那就可以继续使用缓存，如果服务器告知已经过期，那就返回新的资源作为新的缓存



控制缓存操作的首部： cache-control，有属性 max-age，代表资源保存为缓存的最长时间，单位是秒； no-cache，并不是不能缓存，而是可以缓存，但每次使用前都要和服务器进行确认，同时代理服务器也不能对资源进行缓存，

no-store，告诉浏览器不要缓存了，每次都要和服务器请求资源，private，表示资源只能给我这个浏览器缓存，其他什么代理服务器都不能进行缓存，如果显示public，那么浏览器和代理服务器都是可以缓存的，

etag：用来标识资源的，一般来说每次资源更新后，新的etag值也会被服务器更新

表示缓存时间的首部：expiress：相当于缓存的过期时间 ，在没到达过期时间之前，都代表资源未过期，因此不会和服务器要求更新资源，但是如果服务器的时钟不同步，那么时间就会出现误差，因此经常和Last-modified配合使用

 Last-modified：表示资源的最后修改时间，这样客户端下次进行请求时就可以检查修改资源时间是否一致



# https

http请求和相应的报文都是明文的，https并不是一个单独的协议，只不过是在http的基础上使用 TLS/SSL 进行加密，这样通信就不容易收到拦截和攻击

TLS/SSL

SSL是TLS 的前身，都是加密安全协议，现在绝大部分浏览器都不支持SSL，而是支持TLS，



加密

对称加密

发送方和接收方使用同样的规则为数据进行加密，也可以说用同样的钥匙来解开密文，这就是对称加密，但是如果有第三方知道加密的规则后，就很容易破解

非对称加密

用两个密钥来进行加密和解密，公钥是所有人都知道的密钥，私钥是持有方才知道的密钥，一般来说私钥就放在服务器里，数据经过公钥加密就只能被私钥解密，而数据经过私钥解密就能用公钥解密，应用到客户端和服务端：服务端拥有成对的私钥和公钥，然后公布自己的公钥让客户端知道，客户端把自己的数据进行加密，加密后用公钥就无法解密，只能用服务端的私钥才能解开



证书

虽然我们现在可以对数据进行加密，但我们还是不知道和我在沟通的是否是自己想要沟通的对象，比如 B站的域名很多人有可能输入错误，这样不法分子可能就会伪装B站域名来让你访问，https解决了这个问题，因为服务端需要申请SSL证书，来证明你这个域名就是大家熟知的B站，注意是SSL证书，而不是TLS证书，因为SSL证书更为人熟知，SSL证书就是保存在源服务器的数据文件，要让SSL证书生效就要向CA申请，即Certificate Authority 证书授权中心，这是第三方机构，这样大家都会信任这个机构颁发的证书，这个证书除了表明域名是谁的，日期等等信息以外，重要的是这个证书里还包含了特定的公钥，简单来说，服务器安装了SSL证书后，用户就可以通过HTTPS访问服务器了。

浏览器也会把HTTP的默认端口80改成HTTPS的默认端口443，

现在浏览器通过HTTPS访问服务器具体会有哪些变化呢？
不同的TLS版本会有不同的变化

以TLS1.2为例子讲解，正常的TCP三次握手是不变的

客户端向服务端打招呼，并把自己支持的TLS版本，加密套件发给服务端，同时还生成了一个随机数给服务端，称为第1随机数

接着服务端向客户端打招呼，服务端确认支持的TLS版本以及选择的加密套件，并且服务端也生成一个随机数发给客户端，这里称为第2随机数，接着服务端把证书和公钥发送给客户端，发送完毕了就告诉客户端发送完毕了

然后客户端这边生成随机数，称为第3随机数，预主密钥，这个预主密钥不会直接发送出去，而是用刚刚收到的公钥进行加密后再发送出去，然后客户端这边的TLS协商已经没问题了，加密开始

服务端收到加密后的预主密钥后，就用自己的私钥进行解密，这样服务器就知道预主密钥了，而且只有客户端和服务端知道这个预主密钥，除非私钥被泄露了，最后客户端用预主密钥、第1随机数、第2随机数计算出会话密钥，同时，服务端通过相同的方式计算出会话密钥，两者得到的会话密钥是相同的

也就是说，前面的步骤都是非对称加密，就是为了得到这个会话密钥，后面的会话大家都只使用这个会话密钥对数据进行加密，也就是说，后面使用的是对称加密，都使用同一个密钥

而后面不使用非对称加密是因为消耗的资源非常大，而且得到会话密钥后就没人知道密钥是什么了，因此后面使用对称加密，如果与其他服务器建立新的会话，会话密钥也不相同，会话密钥只应用在当前会话，更加提高了安全性

![image-20230318215537707](C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230318215537707.png)

现象： 

我们用访问 `http://www.12306.cn` 会提示不安全链接，而是用 `https://www.12306.cn` 就是安全

17年1月发布的 Chrome 56 浏览器开始把收集密码或信用卡数据的 HTTP 页面标记为”不安全“， 此外，苹果强制所有的 IOS APP 使用 HTTPS 加密



发展史

HTTP协议是一个基于请求与响应，无状态的，应用层协议，常基于 TCP/IP 协议传输数据， 设计的初衷是为了提供一种发送和接收HTML页面的方法

| 版本     | 时间 | 内容                                                         | 处境               |
| -------- | ---- | ------------------------------------------------------------ | ------------------ |
| HTTP/0.9 | 1991 | 不涉及数据包传输，规定客户端和服务器之间的通信格式，只能GET请求 | 没有作为正式的标准 |
| HTTP/1.0 | 1996 | 传输内容格式不限制，增加 PUT,PATCH,HEAD,OPTIONS,DELETE命令   | 正式作为标准       |
| HTTP/1.1 | 1997 | 持久链接、节约带宽、HOST域、管道机制、分块传输编码           | 2015年使用最广泛   |
| HTTP/2   | 2015 | 多路复用、服务器推送、头信息压缩、二进制协议等               | 逐渐覆盖市场       |



![image-20230317113254092](C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230317113254092.png)



多路复用： 通过单一的 HTTP/2 连接请求发起多重请求和 响应消息，多个 stream 共享一个TCP连接，实现多路并行而不是建立多个 TCP 连接



HTTPS 是身披 SSL 外壳的 HTTP， HTTPS 是一种通过计算机网络进行安全通信的传输协议，经由HTTP 通信， 利用 SSL/TLS 建立安全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私域完整性



HTTP VS HTTPS

HTTP

1. 无状态：协议对客户端没有状态储存，对事物处理没有 "记忆能力"，比如访问一个网站需要反复地进行登录操作
2. 无连接：HTTP/1.1 之前， 由于无状态地特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接，比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，耗费不必要地时间和流量
3. 基于请求和响应：基本地特性，由客户端发起请求，服务端响应
4. 简单快速，灵活
5. 通信使用明文、请求和响应不会对通信方进行确认，无法保护数据的完整性







HTTPS

基于HTTP协议，通过 SSL或 TLS 提供加密处理数据，验证对方身份以及数据完整性保护

1. 内容加密：采用混合加密技术，中间者无法直接查看明文内容
2. 验证身份：通过证书认证客户端访问地是自己的服务器
3. 保护数据完整性：防止传输的内容被中间人冒充或篡改



实现原理